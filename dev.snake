def sim_agg_he_truebeta_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/celltypebeta.txt', params=subspace.instance_patterns)

def sim_agg_he_trueV_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/V.txt', params=subspace.instance_patterns)

def sim_agg_he_trueW_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/W.txt', params=subspace.instance_patterns)

def sim_agg_reml_truebeta_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)])
    return expand('analysis/sim/{{model}}/{params}/celltypebeta.txt', params=subspace.instance_patterns)

def sim_agg_reml_trueV_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)])
    return expand('analysis/sim/{{model}}/{params}/V.txt', params=subspace.instance_patterns)

def sim_agg_reml_trueW_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)])
    return expand('analysis/sim/{{model}}/{params}/W.txt', params=subspace.instance_patterns)

def sim_agg_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/out.npy', params=subspace.instance_patterns)

def sim_agg_he_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/out.he.npy', params=subspace.instance_patterns)

def sim_agg_reml_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)])
    return expand('analysis/sim/{{model}}/{params}/out.reml.npy', params=subspace.instance_patterns)

rule sim_HEestimates_subspace_plot:
    input:
        out = sim_agg_he_out_subspace,
        V = sim_agg_he_trueV_subspace,
        W = sim_agg_he_trueW_subspace,
    output:
        png = 'results/sim/{model}/HE.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[sim_params['model']==wildcards.model]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        method = None,
        mycolors = mycolors,
        pointcolor = pointcolor,
        colorpalette = colorpalette,
    script: 'scripts/sim/estimates_subspace_plot.py'

rule sim_HEwald_subspace_plot:
    input:
        out = sim_agg_he_out_subspace,
    output:
        png = 'results/sim/{model}/HE.wald.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[sim_params['model']==wildcards.model]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        mycolors = mycolors,
    script: 'scripts/sim/HEwald_subspace_plot.py'

rule sim_REMLestimates_subspace_plot:
    input:
        out = sim_agg_reml_out_subspace,
        beta = sim_agg_reml_truebeta_subspace, 
        V = sim_agg_reml_trueV_subspace,
        W = sim_agg_reml_trueW_subspace,
    output:
        png = 'results/sim/{model}/REML.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        method = None,
        colorpalette = colorpalette,
        pointcolor = pointcolor,
        mycolors = mycolors,
    script: 'scripts/sim/estimates_subspace_plot.py'

rule sim_REMLwaldNlrt_subspace_plot:
    input:
        out = sim_agg_reml_out_subspace,
    output:
        png = 'results/sim/{model}/REML.waldNlrt.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[(sim_params['model']==wildcards.model) & (sim_params['ss'].astype('float')<300)]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        mycolors = mycolors,
    script: 'scripts/sim/REMLwaldNlrt_subspace_plot.py'

rule sim_collect_HEnREML_subspace_plot:
    input:
        he = 'results/sim/{model}/HE.AGG{arg}.png',
        he_wald = 'results/sim/{model}/HE.wald.AGG{arg}.png',
        reml = 'results/sim/{model}/REML.AGG{arg}.png', 
        reml_waldNlrt = 'results/sim/{model}/REML.waldNlrt.AGG{arg}.png',
    output:
        flag = touch('staging/sim/{model}/HEnREML.AGG{arg}.flag'),

def sim_HEnREML_AGGarg_fun(wildcards):
    effective_args = get_effective_args(sim_params.loc[sim_params['model']==wildcards.model])
    return expand('staging/sim/{{model}}/HEnREML.AGG{arg}.flag', arg=effective_args)

rule sim_AGGarg:
    input:
        sim_HEnREML_AGGarg_fun,
    output:
        flag = touch('staging/sim/{model}/all.flag'),

rule sim_all:
    input:
        flag = expand('staging/sim/{model}/all.flag', model=['free','freeW','full']),

########################################################################
# Real data
########################################################################
rule gene_annotation_comparison:
    input:
        v24 = 'data/gencode.v24lift37.annotation.gff3.gz',
        v43 = 'data/gencode.v43lift37.annotation.gff3.gz',
        v82 = 'data/Homo_sapiens.GRCh37.82.gff3.gz',
        v85 = 'data/Homo_sapiens.GRCh37.85.gff3.gz',
        genes = 'data/Yazar2022Science/genes.txt',
    output:
        results = 'data/gene.annotation.txt',
    run:
        import gzip, re
        def read_gencode(f):
            res = {}
            for line in gzip.open(f, 'rt'):
                if line[0] != '#':
                    line = line.strip().split()
                    if line[2] == 'gene' and re.search('chr',line[0]) and line[0][3:].isdigit():
                        try:
                            chr, start, end, info = int(line[0][3:]), int(line[3]), int(line[4]), line[-1]
                            info = info.split(';')
                            gene = info[0].split('.')[0][3:]
                            res[gene] = {'chr':chr, 'start':start, 'end':end}
                        except:
                            print(line)
                            sys.exit()
            return( res )

        def read_ensembl(f):
            res = {}
            chrs = []
            for line in gzip.open(f, 'rt'):
                if line[0] != '#':
                    line = line.strip().split('\t')
                    if 'ID=gene' in line[-1] and line[0].isdigit():
                        try:
                            chr, start, end, info = int(line[0]), int(line[3]), int(line[4]), line[-1]
                            info = info.split(';')
                            gene = info[0].split(':')[1]
                            res[gene] = {'chr':chr, 'start':start, 'end':end}
                            chrs.append( chr )
                        except:
                            print(line)
                            sys.exit()
            print( np.unique( chrs, return_counts=True) )
            return( res )

        def compare_genes(v1, v2):
            v1_v2 = set(v1.keys()) & set(v2.keys())
            match = []
            close = []
            for gene in v1_v2:
                v1_gene, v2_gene = v1[gene], v2[gene]
                if v1_gene['chr'] == v2_gene['chr'] and v1_gene['start'] == v2_gene['start'] and v1_gene['end'] == v2_gene['end']:
                    match.append(gene)
                elif v1_gene['chr'] == v2_gene['chr'] and abs(v1_gene['start'] - v2_gene['start']) < 1000 and abs(v1_gene['end'] - v2_gene['end']) < 1000:
                    close.append(gene)
            return( len(v1_v2), len(match), len(close) )

        v24 = read_gencode(input.v24)
        v43 = read_gencode(input.v43)
        v82 = read_ensembl(input.v82)
        v85 = read_ensembl(input.v85)

        genes = pd.read_table(input.genes)['feature'].tolist()
        with open(output.results, 'w') as f:
            f.write(f'{len(v24.keys())}, {len(v43.keys())}, {len(v85.keys())},  and {len(v82.keys())} genes in v24, v43, v85, and v82.\n')
            f.write(f'{len(set(v24.keys()) & set(genes))} v24 genes in data.\n')
            f.write(f'{len(set(v43.keys()) & set(genes))} v43 genes in data.\n')
            f.write(f'{len(set(v82.keys()) & set(genes))} v82 genes in data.\n')
            f.write(f'{len(set(v85.keys()) & set(genes))} v85 genes in data.\n')
            f.write('%i genes overlap between v24 and v43. %i match, and %i close.\n'%(compare_genes(v24,v43)))
            f.write('%i genes overlap between v24 and v82. %i match, and %i close.\n'%(compare_genes(v24,v82)))
            f.write('%i genes overlap between v43 and v82. %i match, and %i close.\n'%(compare_genes(v43,v82)))
            f.write('%i genes overlap between v43 and v85. %i match, and %i close.\n'%(compare_genes(v43,v85)))

########################################################################
# Yazar 2022 Science
########################################################################
# data check
rule yazar_cell_dist:
    input:
        obs = 'data/Yazar2022Science/obs.txt',
    output:
        png = 'results/yazar/cell.dist.png',
    params:
        ind_col = yazar_ind_col,
        ct_col = yazar_ct_col,
    script: 'scripts/yazar/cell_dist.py'

rule yazar_impute_ctp_s1:
    input:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.gz',
    output:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.b_imputed.gz',
    resources:
        mem_mb = '10G',
        time = '36:00:00',
    run:
        from ctmm import preprocess
        data = pd.read_table(input.data, index_col=(0,1)).astype('float32')
        #data = preprocess.softimpute(data, seed=params.seed)
        data = data.unstack()
        data.to_csv(output.data, sep='\t', index=False, header=False)

rule yazar_impute_ctp_s2:
    # softimpute is too slow for the whold transcriptome
    input:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.b_imputed.gz',
    output:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.a_imputed.gz',
    params:
        seed = 1234567,
    resources:
        mem_mb = '40G',
        time = '36:00:00',
    script: 'bin/yazar/impute.R'


# gcta
rule yazar_gcta_grm:
    input:
        genes = 'data/Yazar2022Science/gene_loation.txt',
        P = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/P.gz',
        bed = 'analysis/yazar/data/geno/chr{chr}.bed',
    output:
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{{chr}}.txt',
    params:
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship/gene.grm.bin',
        r = int(float(5e5)),
    resources:
        mem_mb = '2G',
    shell:
        '''
        module load gcc/11.3.0 atlas/3.10.3 lapack/3.11.0 plink/1.9
        module load gcc/11.3.0 gcta/1.94.1
        mkdir -p $(dirname {params.kinship})
        python3 bin/yazar/kinship.py \
                {input.genes} {input.P} {params.r} \
                {input.bed} {wildcards.chr} \
                {params.kinship} {output.kinship}
        '''

#use rule yazar_he_kinship_merge as yazar_gcta_grm_merge with:
#    input:
#        kinship = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{chr}.txt'
#                for chr in range(1,23)],
#    output:
#        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.txt',
#        save = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.txt',

#rule yazar_gcta_HEreg_op:
#    # covar and qcovar is not working in GCTA HE!!!!
#    input:
#        op = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/op.mvn.gz',
#        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{{chr}}.txt',
#        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
#        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
#        meta = 'data/Yazar2022Science/meta.txt',
#    output:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg.chr{{chr}}',
#    params:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/rep/op.HEreg',
#        snps = 5, # threshold of snp number per gene
#    resources:
#        time = '10:00:00',
#        mem_mb = '2G',
#    shell:
#        '''
#        module load gcc/11.3.0 gcta/1.94.1
#        python3 scripts/yazar/gcta_HEreg_op.py \
#                {input.op} {input.kinship} \
#                {input.op_pca} {input.geno_pca} \
#                {input.meta} {params.snps} {params.out} {output.out}
#        '''
#
#rule yazar_gcta_HEreg_op_merge:
#    input:
#        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg.chr{chr}'
#                for chr in range(1,23)],
#    output:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg',
#    run:
#        with open(output.out, 'w') as f:
#            f.write('gene\th2\n')
#            for chr_out in input.out:
#                for gene_out in open(chr_out):
#                    gene = re.search(r"/(ENSG[^/]+)/", gene_out).group(1)
#                    for line in open(gene_out.strip()):
#                        if re.search(r'V\(G\)\/Vp', line):
#                            h2 = line.strip().split()[1]
#                            break
#                    f.write(f'{gene}\t{h2}\n')
            
rule yazar_gcta_greml_op:
    input:
        op = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/op.mvn.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{{chr}}.txt',
        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'analysis/yazar/exclude_repeatedpool.obs.txt',
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml.chr{{chr}}',
    params:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/rep/op.hsq',
        snps = 5, # threshold of snp number per gene
    resources:
        time = '10:00:00',
        mem_mb = '2G',
    shell:
        '''
        module load gcc/11.3.0 gcta/1.94.1
        python3 scripts/yazar/gcta_greml_op.py \
                {input.op} {input.kinship} \
                {input.op_pca} {input.geno_pca} \
                {input.obs} {params.snps} {params.out} {output.out}
        '''

rule yazar_gcta_greml_op_merge:
    input:
        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml.chr{chr}'
                for chr in range(1,23)],
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml',
    run:
        with open(output.out, 'w') as f:
            f.write('gene\th2\n')
            for chr_out in input.out:
                for gene_out in open(chr_out):
                    gene = re.search(r"/(ENSG[^/]+)/", gene_out).group(1)
                    for line in open(gene_out.strip()):
                        if re.search(r'V\(G\)\/Vp', line):
                            h2 = line.strip().split()[1]
                            break
                    f.write(f'{gene}\t{h2}\n')
