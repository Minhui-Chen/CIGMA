reml_ss_cut = 1000

def sim_agg_he_truebeta_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/celltypebeta.txt', params=subspace.instance_patterns)

def sim_agg_he_trueV_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/V.txt', params=subspace.instance_patterns)

def sim_agg_he_trueW_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/W.txt', params=subspace.instance_patterns)

def sim_agg_reml_truebeta_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) 
        & (sim_params['ss'].astype('float') <= reml_ss_cut)])
    return expand('analysis/sim/{{model}}/{params}/celltypebeta.txt', params=subspace.instance_patterns)

def sim_agg_reml_trueV_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) 
        & (sim_params['ss'].astype('float') <= reml_ss_cut)])
    return expand('analysis/sim/{{model}}/{params}/V.txt', params=subspace.instance_patterns)

def sim_agg_reml_trueW_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) 
        & (sim_params['ss'].astype('float') <= reml_ss_cut)])
    return expand('analysis/sim/{{model}}/{params}/W.txt', params=subspace.instance_patterns)

def sim_agg_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/out.npy', params=subspace.instance_patterns)

def sim_agg_he_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('analysis/sim/{{model}}/{params}/out.he.npy', params=subspace.instance_patterns)

def sim_agg_reml_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[(sim_params['model']==wildcards.model) 
        & (sim_params['ss'].astype('float') <= reml_ss_cut)])
    return expand('analysis/sim/{{model}}/{params}/out.reml.npy', params=subspace.instance_patterns)

rule sim_HEestimates_subspace_plot:
    input:
        out = sim_agg_he_out_subspace,
        V = sim_agg_he_trueV_subspace,
        W = sim_agg_he_trueW_subspace,
    output:
        png = 'results/sim/{model}/HE.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[sim_params['model']==wildcards.model]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        method = None,
        mycolors = mycolors,
        pointcolor = pointcolor,
        colorpalette = colorpalette,
    script: 'scripts/sim/estimates_subspace_plot.py'

rule sim_HEwald_subspace_plot:
    input:
        out = sim_agg_he_out_subspace,
    output:
        png = 'results/sim/{model}/HE.wald.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[sim_params['model']==wildcards.model]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        mycolors = mycolors,
    script: 'scripts/sim/HEwald_subspace_plot.py'

rule sim_REMLestimates_subspace_plot:
    input:
        out = sim_agg_reml_out_subspace,
        beta = sim_agg_reml_truebeta_subspace, 
        V = sim_agg_reml_trueV_subspace,
        W = sim_agg_reml_trueW_subspace,
    output:
        png = 'results/sim/{model}/REML.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[(sim_params['model']==wildcards.model) 
                    & (sim_params['ss'].astype('float') <= reml_ss_cut)]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        method = None,
        colorpalette = colorpalette,
        pointcolor = pointcolor,
        mycolors = mycolors,
    script: 'scripts/sim/estimates_subspace_plot.py'

rule sim_REMLwaldNlrt_subspace_plot:
    input:
        out = sim_agg_reml_out_subspace,
    output:
        png = 'results/sim/{model}/REML.waldNlrt.AGG{arg}.png',
    params:
        subspace = lambda wildcards: get_subspace(wildcards.arg,
                sim_params.loc[(sim_params['model']==wildcards.model) 
                    & (sim_params['ss'].astype('float') <= reml_ss_cut)]).iloc[:,:],
        sim_plot_order = sim_plot_order,
        mycolors = mycolors,
    script: 'scripts/sim/REMLwaldNlrt_subspace_plot.py'

rule sim_collect_HEnREML_subspace_plot:
    input:
        he = 'results/sim/{model}/HE.AGG{arg}.png',
        he_wald = 'results/sim/{model}/HE.wald.AGG{arg}.png',
        reml = 'results/sim/{model}/REML.AGG{arg}.png', 
        reml_waldNlrt = 'results/sim/{model}/REML.waldNlrt.AGG{arg}.png',
    output:
        flag = touch('staging/sim/{model}/HEnREML.AGG{arg}.flag'),

def sim_HEnREML_AGGarg_fun(wildcards):
    effective_args = get_effective_args(sim_params.loc[sim_params['model']==wildcards.model])
    return expand('staging/sim/{{model}}/HEnREML.AGG{arg}.flag', arg=effective_args)

rule sim_AGGarg:
    input:
        sim_HEnREML_AGGarg_fun,
    output:
        flag = touch('staging/sim/{model}/all.flag'),

rule sim_all:
    input:
        flag = expand('staging/sim/{model}/all.flag', model=['free','freeW','full']),

################## 1.2 HE without JK ############
rule sim_HE_noJK:
    input:
        Y = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/Y.batch{{i}}.txt',
        K = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/K.batch{{i}}.txt',
        ctnu = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/ctnu.batch{{i}}.txt',
        P = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/P.batch{{i}}.txt',
    output:
        out = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/he.noJK.batch{{i}}',
    params:
        out = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/rep/he.noJK.npy',
        batches = lambda wildcards: sim_batches[int(wildcards.i)],
    resources:
        time = '10:00:00',
        mem_mb = lambda wildcards: f'{max(1,int(float(wildcards.ss))//150)}G',
    priority: 1
    script: 'scripts/sim/he.py'

use rule sim_mergeBatches_HE as sim_mergeBatches_HE_noJK with:
    input:
        out = [f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/he.noJK.batch{i}'
                for i in range(sim_batch_no)],
    output:
        out = f'staging/sim/{{model}}/{sim_paramspace.wildcard_pattern}/out.he.noJK.npy',

def sim_agg_he_noJK_out_subspace(wildcards):
    subspace = get_subspace(wildcards.arg, sim_params.loc[sim_params['model']==wildcards.model])
    return expand('staging/sim/{{model}}/{params}/out.he.noJK.npy', params=subspace.instance_patterns)

use rule sim_HEestimates_subspace_plot as sim_HE_noJK_estimates_subspace_plot with:
    input:
        out = sim_agg_he_noJK_out_subspace,
        V = sim_agg_he_trueV_subspace,
        W = sim_agg_he_trueW_subspace,
    output:
        png = 'results/sim/{model}/HE.noJK.AGG{arg}.png',

########################################################################
# Real data
########################################################################
rule gene_annotation_comparison:
    input:
        v24 = 'data/gencode.v24lift37.annotation.gff3.gz',
        v43 = 'data/gencode.v43lift37.annotation.gff3.gz',
        v82 = 'data/Homo_sapiens.GRCh37.82.gff3.gz',
        v85 = 'data/Homo_sapiens.GRCh37.85.gff3.gz',
        genes = 'data/Yazar2022Science/genes.txt',
    output:
        results = 'data/gene.annotation.txt',
    run:
        import gzip, re
        def read_gencode(f):
            res = {}
            for line in gzip.open(f, 'rt'):
                if line[0] != '#':
                    line = line.strip().split()
                    if line[2] == 'gene' and re.search('chr',line[0]) and line[0][3:].isdigit():
                        try:
                            chr, start, end, info = int(line[0][3:]), int(line[3]), int(line[4]), line[-1]
                            info = info.split(';')
                            gene = info[0].split('.')[0][3:]
                            res[gene] = {'chr':chr, 'start':start, 'end':end}
                        except:
                            print(line)
                            sys.exit()
            return( res )

        def read_ensembl(f):
            res = {}
            chrs = []
            for line in gzip.open(f, 'rt'):
                if line[0] != '#':
                    line = line.strip().split('\t')
                    if 'ID=gene' in line[-1] and line[0].isdigit():
                        try:
                            chr, start, end, info = int(line[0]), int(line[3]), int(line[4]), line[-1]
                            info = info.split(';')
                            gene = info[0].split(':')[1]
                            res[gene] = {'chr':chr, 'start':start, 'end':end}
                            chrs.append( chr )
                        except:
                            print(line)
                            sys.exit()
            print( np.unique( chrs, return_counts=True) )
            return( res )

        def compare_genes(v1, v2):
            v1_v2 = set(v1.keys()) & set(v2.keys())
            match = []
            close = []
            for gene in v1_v2:
                v1_gene, v2_gene = v1[gene], v2[gene]
                if v1_gene['chr'] == v2_gene['chr'] and v1_gene['start'] == v2_gene['start'] and v1_gene['end'] == v2_gene['end']:
                    match.append(gene)
                elif v1_gene['chr'] == v2_gene['chr'] and abs(v1_gene['start'] - v2_gene['start']) < 1000 and abs(v1_gene['end'] - v2_gene['end']) < 1000:
                    close.append(gene)
            return( len(v1_v2), len(match), len(close) )

        v24 = read_gencode(input.v24)
        v43 = read_gencode(input.v43)
        v82 = read_ensembl(input.v82)
        v85 = read_ensembl(input.v85)

        genes = pd.read_table(input.genes)['feature'].tolist()
        with open(output.results, 'w') as f:
            f.write(f'{len(v24.keys())}, {len(v43.keys())}, {len(v85.keys())},  and {len(v82.keys())} genes in v24, v43, v85, and v82.\n')
            f.write(f'{len(set(v24.keys()) & set(genes))} v24 genes in data.\n')
            f.write(f'{len(set(v43.keys()) & set(genes))} v43 genes in data.\n')
            f.write(f'{len(set(v82.keys()) & set(genes))} v82 genes in data.\n')
            f.write(f'{len(set(v85.keys()) & set(genes))} v85 genes in data.\n')
            f.write('%i genes overlap between v24 and v43. %i match, and %i close.\n'%(compare_genes(v24,v43)))
            f.write('%i genes overlap between v24 and v82. %i match, and %i close.\n'%(compare_genes(v24,v82)))
            f.write('%i genes overlap between v43 and v82. %i match, and %i close.\n'%(compare_genes(v43,v82)))
            f.write('%i genes overlap between v43 and v85. %i match, and %i close.\n'%(compare_genes(v43,v85)))

########################################################################
# Yazar 2022 Science
########################################################################
# data check
rule yazar_cell_dist:
    input:
        obs = 'data/Yazar2022Science/obs.txt',
    output:
        png = 'results/yazar/cell.dist.png',
    params:
        ind_col = yazar_ind_col,
        ct_col = yazar_ct_col,
    script: 'scripts/yazar/cell_dist.py'

rule yazar_impute_ctp_s1:
    input:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.gz',
    output:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.b_imputed.gz',
    resources:
        mem_mb = '10G',
        time = '36:00:00',
    run:
        from ctmm import preprocess
        data = pd.read_table(input.data, index_col=(0,1)).astype('float32')
        #data = preprocess.softimpute(data, seed=params.seed)
        data = data.unstack()
        data.to_csv(output.data, sep='\t', index=False, header=False)

rule yazar_impute_ctp_s2:
    # softimpute is too slow for the whold transcriptome
    input:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.b_imputed.gz',
    output:
        data = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/ctp.a_imputed.gz',
    params:
        seed = 1234567,
    resources:
        mem_mb = '40G',
        time = '36:00:00',
    script: 'bin/yazar/impute.R'


############################ 1.2 gcta ###################################
rule yazar_gcta_grm:
    input:
        genes = 'data/Yazar2022Science/gene_loation.txt',
        P = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/P.gz',
        bed = 'analysis/yazar/data/geno/chr{chr}.bed',
    output:
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{{chr}}.txt',
    params:
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship/gene.grm.bin',
        r = int(float(5e5)),
    resources:
        mem_mb = '2G',
    shell:
        '''
        module load gcc/11.3.0 atlas/3.10.3 lapack/3.11.0 plink/1.9
        module load gcc/11.3.0 gcta/1.94.1
        mkdir -p $(dirname {params.kinship})
        python3 bin/yazar/kinship.py \
                {input.genes} {input.P} {params.r} \
                {input.bed} {wildcards.chr} \
                {params.kinship} {output.kinship}
        '''

#use rule yazar_he_kinship_merge as yazar_gcta_grm_merge with:
#    input:
#        kinship = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{chr}.txt'
#                for chr in range(1,23)],
#    output:
#        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.txt',
#        save = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.txt',

#rule yazar_gcta_HEreg_op:
#    # covar and qcovar is not working in GCTA HE!!!!
#    input:
#        op = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/op.mvn.gz',
#        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{{chr}}.txt',
#        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
#        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
#        meta = 'data/Yazar2022Science/meta.txt',
#    output:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg.chr{{chr}}',
#    params:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/rep/op.HEreg',
#        snps = 5, # threshold of snp number per gene
#    resources:
#        time = '10:00:00',
#        mem_mb = '2G',
#    shell:
#        '''
#        module load gcc/11.3.0 gcta/1.94.1
#        python3 scripts/yazar/gcta_HEreg_op.py \
#                {input.op} {input.kinship} \
#                {input.op_pca} {input.geno_pca} \
#                {input.meta} {params.snps} {params.out} {output.out}
#        '''
#
#rule yazar_gcta_HEreg_op_merge:
#    input:
#        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg.chr{chr}'
#                for chr in range(1,23)],
#    output:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.HEreg',
#    run:
#        with open(output.out, 'w') as f:
#            f.write('gene\th2\n')
#            for chr_out in input.out:
#                for gene_out in open(chr_out):
#                    gene = re.search(r"/(ENSG[^/]+)/", gene_out).group(1)
#                    for line in open(gene_out.strip()):
#                        if re.search(r'V\(G\)\/Vp', line):
#                            h2 = line.strip().split()[1]
#                            break
#                    f.write(f'{gene}\t{h2}\n')

kinship_batches = 500
rule yazar_gcta_split_kinship:
    input:
        kinship = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.chr{chr}.txt'
                for chr in range(1,23)],
    output:
        kinship = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.batch{i}.txt'
                for i in range(kinship_batches)],
    run:
        kinship = [pd.read_table(f) for f in input.kinship]
        kinship = pd.concat(kinship, axis=0, ignore_index=True)
        indexs = np.array_split(kinship.index, len(output.kinship))
        for index, f in zip(indexs, output.kinship):
            kinship.loc[index].to_csv(f, sep='\t', index=False)

rule yazar_gcta_greml_op:
    input:
        op = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/op.mvn.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.batch{{i}}.txt',
        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'analysis/yazar/exclude_repeatedpool.obs.txt',
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml.batch{{i}}',
    params:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/rep/op.hsq',
        snps = 5, # threshold of snp number per gene
    resources:
        time = '200:00:00',
        mem_mb = '2G',
    shell:
        '''
        module load gcc/11.3.0 gcta/1.94.1
        python3 scripts/yazar/gcta_greml_op.py \
                {input.op} {input.kinship} \
                {input.op_pca} {input.geno_pca} \
                {input.obs} {params.snps} {params.out} {output.out}
        '''

rule yazar_gcta_greml_op_merge:
    input:
        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml.batch{i}'
                for i in range(kinship_batches)],
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml',
    run:
        with open(output.out, 'w') as f:
            f.write('gene\th2\n')
            for chr_out in input.out:
                for gene_out in open(chr_out):
                    gene = re.search(r"/(ENSG[^/]+)/", gene_out).group(1)
                    for line in open(gene_out.strip()):
                        if re.search(r'V\(G\)\/Vp', line):
                            h2 = line.strip().split()[1]
                            break
                    f.write(f'{gene}\t{h2}\n')

rule yazar_gcta_greml_op_plot:
    input:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml',
    output:
        png = f'results/yazar/{yazar_paramspace.wildcard_pattern}/gcta/op.greml.png',
    script: 'scripts/yazar/gcta_op_plot.py'

rule yazar_gcta_greml_ctp:
    input:
        ctp = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/ctp.mvn.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.batch{{i}}.txt',
        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'analysis/yazar/exclude_repeatedpool.obs.txt',
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.batch{{i}}',
    params:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/rep/ctp.hsq',
        snps = 5, # threshold of snp number per gene
    resources:
        time = '200:00:00',
        mem_mb = '2G',
    shell:
        '''
        module load gcc/11.3.0 gcta/1.94.1
        python3 scripts/yazar/gcta_greml_ctp.py \
                {input.ctp} {input.kinship} \
                {input.op_pca} {input.geno_pca} \
                {input.obs} {params.snps} {params.out} {output.out}
        '''

rule yazar_gcta_greml_ctp_merge:
    input:
        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.batch{i}'
                for i in range(kinship_batches)],
    output:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml',
    run:
        with open(output.out, 'w') as f:
            f.write('ct\tgene\th2\n')
            for chr_out in input.out:
                for gene_out in open(chr_out):
                    gene_ct = re.search(r"/(ENSG[^/]+)/", gene_out).group(1)
                    gene, ct = gene_ct.split('_')
                    for line in open(gene_out.strip()):
                        if re.search(r'V\(G\)\/Vp', line):
                            h2 = line.strip().split()[1]
                            break
                    f.write(f'{ct}\t{gene}\t{h2}\n')

rule yazar_gcta_greml_ctp_plot:
    input:
        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml',
    output:
        png = f'results/yazar/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.png',
    script: 'scripts/yazar/gcta_ctp_plot.py'

rule yazar_gcta_all:
    input:
        op = expand('results/yazar/{params}/gcta/op.greml.png',
                params=yazar_paramspace.instance_patterns),
        ctp = expand('results/yazar/{params}/gcta/ctp.greml.png',
                params=yazar_paramspace.instance_patterns),

####################### 1.2: combine all cts together except for one  ######################
combine_cts = {
        'cc1':  {
            'B': ['B IN', 'B Mem'],
            'CD4': ['CD4 ET', 'CD4 NC'],
            'CD8': ['CD8 ET', 'CD8 NC', 'CD8 S100B'],
            },

        'cc2':  {
            'main':  ['B IN', 'B Mem', 'CD4 ET', 'CD4 NC', 'CD8 ET', 'CD8 NC', 'CD8 S100B'],
            }
        }

wildcard_constraints: cc='[\w\d]+'

rule yazar_combine_cts:
    input:
        obs = 'staging/data/yazar/obs.gz',
    output:
        obs = 'staging/data/yazar/combine_cts/{cc}/obs.gz',
    params:
        cc = lambda wildcards: combine_cts[wildcards.cc],
    run:
        obs = pd.read_table(input.obs)
        for key, value in params.cc.items():
            obs.loc[obs['cell_label'].isin(value), 'cell_label'] = key
        obs.to_csv(output.obs, sep='\t', index=False)

use rule yazar_ctp as yazar_cc_ctp with:
    input:
        X = 'staging/data/yazar/X.npz',
        obs = 'staging/data/yazar/combine_cts/{cc}/obs.gz',
        var = 'staging/data/yazar/var.gz',
    output:
        ctp = 'staging/yazar/combine_cts/{cc}/ctp.gz',
        ctnu = 'staging/yazar/combine_cts/{cc}/ctnu.gz',
        P = 'staging/yazar/combine_cts/{cc}/P.gz',
        n = 'staging/yazar/combine_cts/{cc}/n.gz',

use rule yazar_rm_rareINDnCT as yazar_cc_rm_rareINDnCT with:
    input:
        ctp = 'staging/yazar/combine_cts/{cc}/ctp.gz',
        ctnu = 'staging/yazar/combine_cts/{cc}/ctnu.gz',
        n = 'staging/yazar/combine_cts/{cc}/n.gz',
    output:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.gz',
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
        n = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/n.gz',

use rule yazar_mvn_ctp as yazar_cc_mvn_ctp with:
    input:
        data = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.gz',
    output:
        data = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.mvn.gz',

use rule yazar_mvn_ctp as yazar_cc_mvn_ctnu with:
    input:
        data = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.gz',
    output:
        data = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.mvn.gz',

use rule yazar_std_op as yazar_cc_std_op with:
    input:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.mvn.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.mvn.gz',
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
    output:
        op = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/op.std.gz',
        nu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/nu.std.gz',
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.std.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.std.gz',

use rule yazar_op_pca as yazar_cc_op_pca with:
    input:
        op = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/op.std.gz',
    output:
        evec = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/evec.txt',
        eval = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/eval.txt',
        pca = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/pca.txt',
        png = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/pca.png',

use rule yazar_HE_split as yazar_cc_HE_split with:
    input:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.std.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctnu.std.gz',
    output:
        ctp = [f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctp.batch{i}.gz'
                for i in range(yazar_he_batches)],
        ctnu = [f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctnu.batch{i}.gz'
                for i in range(yazar_he_batches)],

use rule yazar_HE_free as yazar_cc_HE_free with:
    input:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctp.batch{{i}}.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctnu.batch{{i}}.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he/kinship.txt',
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
        op_pca = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'staging/data/yazar/combine_cts/{cc}/obs.gz',
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he.free.batch{{i}}',
    params:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/rep/he.free.npy',
        snps = 5, # threshold of snp number per gene

use rule yazar_HE_free_merge as yazar_cc_HE_free_merge with:
    input:
        out = [f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he.free.batch{i}'
                for i in range(yazar_he_batches)],
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he.free.npy',

use rule yazar_HE_Free_plot as yazar_cc_HE_Free_plot with:
    input:
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he.free.npy',
    output:
        h2 = f'results/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he.free.h2.png',

rule yazar_cc_all:
    input:
        h2 = expand('results/yazar/combine_cts/{cc}/{params}/he.free.h2.png', 
                cc=list(combine_cts.keys()), 
                params=yazar_paramspace.instance_patterns),

##################### 1.2.3 gcta ##################################
use rule yazar_gcta_greml_ctp as yazar_cc_gcta_greml_ctp with:
    input:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/ctp.std.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/gcta/kinship.batch{{i}}.txt',
        op_pca = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'staging/data/yazar/combine_cts/{cc}/obs.gz',
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.batch{{i}}',

use rule yazar_gcta_greml_ctp_merge as yazar_cc_gcta_greml_ctp_merge with:
    input:
        out = [f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.batch{i}'
                for i in range(kinship_batches)],
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml',

use rule yazar_gcta_greml_ctp_plot as yazar_cc_gcta_greml_ctp_plot with:
    input:
        out = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml',
    output:
        png = f'results/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/gcta/ctp.greml.png',

rule yazar_cc_gcta_all:
    input:
        png = expand('results/yazar/combine_cts/{cc}/{params}/gcta/ctp.greml.png',
                cc=list(combine_cts.keys()), 
                params=yazar_paramspace.instance_patterns),

##################### 1.2 get rid of ctnu ##########################
rule yazar_ccNOctnu_HE_free:
    input:
        ctp = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctp.batch{{i}}.gz',
        ctnu = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/he/ctnu.batch{{i}}.gz',
        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he/kinship.txt',
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
        op_pca = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/pca.txt',
        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
        obs = 'staging/data/yazar/combine_cts/{cc}/obs.gz',
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/he.free.batch{{i}}',
    params:
        out = f'staging/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/rep/he.free.npy',
        snps = 5, # threshold of snp number per gene
    script: 'scripts/yazar/he.free.ccNOctnu.py'

use rule yazar_HE_free_merge as yazar_ccNOctnu_HE_free_merge with:
    input:
        out = [f'staging/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/he.free.batch{i}'
                for i in range(yazar_he_batches)],
    output:
        out = f'staging/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/he.free.npy',

use rule yazar_HE_Free_plot as yazar_ccNOctnu_HE_Free_plot with:
    input:
        P = f'staging/yazar/combine_cts/{{cc}}/{yazar_paramspace.wildcard_pattern}/P.gz',
        out = f'staging/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/he.free.npy',
    output:
        h2 = f'results/yazar/combine_cts/{{cc}}/noctnu/{yazar_paramspace.wildcard_pattern}/he.free.h2.png',

rule yazar_ccNOctnu_all:
    input:
        h2 = expand('results/yazar/combine_cts/{cc}/noctnu/{params}/he.free.h2.png', 
                cc=list(combine_cts.keys()), 
                params=yazar_paramspace.instance_patterns),


########### 1.2 correct for P cell type proportions (not implemented) ################
#rule yazar_HE_free_adjP:
#    input:
#        ctp = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he/ctp.batch{{i}}.gz',
#        ctnu = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he/ctnu.batch{{i}}.gz',
#        kinship = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he/kinship.txt',
#        P = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/P.gz',
#        op_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/pca.txt',
#        geno_pca = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/geno.eigenvec',
#        obs = 'staging/data/yazar/obs.gz',
#    output:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he.free.adjP.batch{{i}}',
#    params:
#        out = f'staging/yazar/{yazar_paramspace.wildcard_pattern}/rep/he.free.adjP.npy',
#        snps = 5, # threshold of snp number per gene
#    resources:
#        time = '10:00:00',
#        mem_mb = '20G',
#    script: 'scripts/yazar/he.free.adjP.py'
#
#use rule yazar_HE_free_merge as yazar_HE_free_merge_adjP with:
#    input:
#        out = [f'staging/yazar/{yazar_paramspace.wildcard_pattern}/he.free.adjP.batch{i}'
#            for i in range(yazar_he_batches)],
#    output:
#        out = f'analysis/yazar/{yazar_paramspace.wildcard_pattern}/he.free.adjP.npy',


